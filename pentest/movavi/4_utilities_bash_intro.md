
### Практическая лекция по Bash. Часть 1: Введение в базовые команды, шибанг и основы работы с командной строкой

#### 1.1 Введение в Bash

Bash (Bourne Again Shell) — это один из наиболее популярных командных интерпретаторов в Linux. Он поддерживает выполнение команд, автоматизацию задач, создание скриптов и множество других функций. В этой лекции мы пройдем путь от самых базовых концепций до сложных конструкций Bash.

#### 1.2 Шибанг (Shebang)

Шибанг — это первая строка в скрипте, которая сообщает системе, какой интерпретатор должен быть использован для выполнения файла. В большинстве случаев это `#!/bin/bash`. Это важно для правильного выполнения скриптов независимо от того, какой шелл установлен по умолчанию в системе.

Пример:

```bash
#!/bin/bash
echo "Привет, мир!"
```

Здесь `#!/bin/bash` указывает системе, что для выполнения скрипта нужно использовать Bash. 

#### 1.3 Базовые команды Bash

Прежде чем начать писать скрипты, нужно освоить основные команды. Некоторые из них:

- **`ls`** — отображает содержимое директории.
- **`pwd`** — выводит путь к текущей директории.
- **`cd`** — изменяет текущую директорию.
- **`echo`** — выводит строку в терминал.
- **`cat`** — читает и выводит содержимое файлов.
  
Пример:

```bash
# Вывод списка файлов в текущей директории
ls

# Переход в домашнюю директорию
cd ~

# Вывод строки "Hello, World!"
echo "Hello, World!"
```

#### 1.4 Пайпы и конвейеры команд

В Linux команды можно соединять друг с другом, передавая вывод одной команды как ввод другой с помощью символа `|` (пайп). Это называется конвейером команд.

Пример:

```bash
# Вывод списка файлов и поиск тех, что содержат "txt"
ls | grep "txt"
```

Здесь `ls` выводит список файлов, а `grep "txt"` фильтрует те, которые содержат слово "txt".

#### 1.5 Специальные символы

В Bash есть множество специальных символов, которые расширяют функциональность команд. Вот некоторые из них:

- **`>`** — перенаправление вывода команды в файл (перезаписывает содержимое файла).
- **`>>`** — добавление вывода команды в файл (дописывает в конец файла).
- **`<`** — перенаправление содержимого файла как ввода для команды.
- **`&`** — выполнение команды в фоне.
  
Пример:

```bash
# Вывод "Hello, World!" в файл hello.txt
echo "Hello, World!" > hello.txt

# Добавление новой строки в файл
echo "Еще одна строка" >> hello.txt

# Чтение файла как входного потока для команды cat
cat < hello.txt
```

#### 1.6 Перенаправление потоков ввода/вывода и ошибок

В Bash можно управлять выводом стандартных потоков данных. Это полезно для разделения стандартного вывода и вывода ошибок.

- **`1>`** — перенаправляет стандартный вывод (stdout).
- **`2>`** — перенаправляет вывод ошибок (stderr).
  
Пример:

```bash
# Перенаправление стандартного вывода в файл
ls > output.txt

# Перенаправление ошибок в файл errors.txt
ls /wrongdirectory 2> errors.txt

# Перенаправление стандартного вывода и ошибок в один файл
ls /wrongdirectory > output.txt 2>&1
```

#### 1.7 Часто используемые конструкции начального уровня

- **`&&`** — выполняет следующую команду, если предыдущая завершилась успешно.
- **`||`** — выполняет следующую команду, если предыдущая завершилась с ошибкой.
  
Пример:

```bash
# Если файл существует, выводим сообщение
[ -f "hello.txt" ] && echo "Файл существует" || echo "Файла нет"
```

#### 1.8 Заключение

Эта первая часть лекции охватила базовые концепции Bash, начиная с основ использования команд и шибанга до пайпов, перенаправлений и специальных символов. В следующей части мы рассмотрим более сложные темы, такие как переменные, аргументы и условия.

Будем использовать эти конструкции для создания более сложных сценариев работы с системными ресурсами и автоматизации задач.

--- 

Во второй части мы перейдем к переменным, аргументам и управляющим конструкциям.


### Практическая лекция по Bash. Часть 2: Переменные, аргументы, управляющие конструкции и циклы

Во второй части лекции мы углубимся в важные темы, такие как переменные, работа с аргументами, управляющие конструкции и циклы в Bash. Это поможет вам создавать более гибкие и мощные скрипты для автоматизации задач.

#### 2.1 Переменные в Bash

Переменные в Bash позволяют сохранять данные для последующего использования. В отличие от многих языков программирования, переменные в Bash не требуют явного указания типа данных.

Пример объявления переменной:

```bash
#!/bin/bash
name="Alice"
echo "Hello, $name!"
```

Здесь переменной `name` присваивается значение `"Alice"`, и оно выводится на экран с помощью команды `echo`. Обратите внимание, что для доступа к значению переменной используется символ `$` перед ее именем.

**Правила работы с переменными:**
- Пробелы вокруг знака `=` не допускаются: `name="Alice"`, но не `name = "Alice"`.
- Переменные чувствительны к регистру: `NAME` и `name` — это разные переменные.

#### 2.2 Аргументы командной строки

Bash позволяет передавать аргументы в скрипты. Аргументы доступны в виде специальных переменных `$1`, `$2` и так далее, где число указывает на порядковый номер аргумента.

Пример:

```bash
#!/bin/bash
echo "Первый аргумент: $1"
echo "Второй аргумент: $2"
```

Выполнение скрипта с аргументами:

```bash
./myscript.sh hello world
```

Вывод будет следующим:

```
Первый аргумент: hello
Второй аргумент: world
```

Кроме того, есть специальные переменные:
- `$#` — количество аргументов.
- `$@` — список всех аргументов.
- `$0` — имя скрипта.

#### 2.3 Управляющие конструкции

Управляющие конструкции позволяют выполнять разные блоки кода в зависимости от условий. В Bash поддерживаются такие конструкции, как `if`, `else`, `elif`, `case`.

Пример с `if`:

```bash
#!/bin/bash
if [ $1 -gt 10 ]; then
    echo "Аргумент больше 10"
elif [ $1 -eq 10 ]; then
    echo "Аргумент равен 10"
else
    echo "Аргумент меньше 10"
fi
```

Здесь проверяется значение первого аргумента, и в зависимости от результата выполняется один из блоков кода.

Пример с `case`:

```bash
#!/bin/bash
case $1 in
    start)
        echo "Запуск сервиса"
        ;;
    stop)
        echo "Остановка сервиса"
        ;;
    restart)
        echo "Перезапуск сервиса"
        ;;
    *)
        echo "Неизвестная команда"
        ;;
esac
```

Конструкция `case` особенно удобна для обработки нескольких вариантов аргументов.

#### 2.4 Циклы

Циклы позволяют выполнять одни и те же действия многократно, что полезно для автоматизации задач.

**Цикл `for`:**

Цикл `for` используется для перебора списка элементов:

```bash
#!/bin/bash
for i in 1 2 3 4 5; do
    echo "Число: $i"
done
```

Вывод:

```
Число: 1
Число: 2
Число: 3
Число: 4
Число: 5
```

**Цикл `while`:**

Цикл `while` выполняет блок кода до тех пор, пока условие истинно:

```bash
#!/bin/bash
counter=1
while [ $counter -le 5 ]; do
    echo "Счетчик: $counter"
    counter=$((counter + 1))
done
```

Здесь счетчик увеличивается на 1 на каждой итерации, пока не достигнет 5.

**Цикл `until`:**

Цикл `until` похож на `while`, но выполняется до тех пор, пока условие ложно:

```bash
#!/bin/bash
counter=1
until [ $counter -gt 5 ]; do
    echo "Счетчик: $counter"
    counter=$((counter + 1))
done
```

#### 2.5 Логические операторы

Логические операторы используются для построения сложных условий:

- **`&&`** — логическое И (условие истинно, если обе части истинны).
- **`||`** — логическое ИЛИ (условие истинно, если хотя бы одна часть истинна).

Пример:

```bash
#!/bin/bash
if [ $1 -gt 10 ] && [ $2 -lt 20 ]; then
    echo "Первый аргумент больше 10, а второй меньше 20"
else
    echo "Условие не выполнено"
fi
```

#### 2.6 Примеры из `.zshrc` и других файлов

Файл `.zshrc` (аналог `.bashrc`) часто используется для настройки окружения. В нем можно встретить циклы, условия и вызовы внешних команд.

Пример `.zshrc`:

```bash
# Пример цикла в .zshrc для загрузки всех плагинов из папки
for plugin in $ZSH/plugins/*; do
    source $plugin
done

# Пример условия для проверки версии zsh
if [[ $ZSH_VERSION == 5.* ]]; then
    echo "Zsh версии 5.x"
fi
```

Этот пример загружает все плагины из определенной директории и проверяет версию Zsh.

#### 2.7 Цветовое оформление

Bash поддерживает вывод цветных сообщений в терминал с помощью управляющих последовательностей ANSI.

Пример вывода текста с цветом:

```bash
#!/bin/bash
RED='\033[0;31m'
NC='\033[0m' # Без цвета (No Color)

echo -e "${RED}Это красный текст${NC}"
```

Здесь используется код `\033[0;31m` для изменения цвета текста на красный, а `\033[0m` сбрасывает цвет к стандартному.

#### 2.8 Заключение

Во второй части лекции мы рассмотрели работу с переменными и аргументами, управляющие конструкции и циклы. Эти элементы являются основными инструментами для создания логики в скриптах. В следующей части мы перейдем к функциям, использованию crontab для планирования задач, а также отладке и тестированию скриптов.


### Практическая лекция по Bash. Часть 3: Определение функций, использование `crontab`, отладка и тестирование скриптов

В последней части лекции мы рассмотрим продвинутые возможности Bash: функции, работу с планировщиком задач `crontab`, а также методы отладки и тестирования скриптов. После этого подведем итоги всей лекции и выделим ключевые моменты.

#### 3.1 Определение и использование функций в Bash

Функции в Bash позволяют группировать команды и многократно использовать их в скрипте. Это делает код более структурированным и повторно используемым.

**Синтаксис определения функции:**

```bash
function имя_функции() {
    команды
}
```

Или:

```bash
имя_функции() {
    команды
}
```

**Пример:**

```bash
#!/bin/bash

# Определение функции
greet() {
    echo "Привет, $1!"
}

# Вызов функции
greet "Алиса"
```

Вывод будет:

```
Привет, Алиса!
```

Здесь функция `greet` принимает один аргумент — имя, которое передается при вызове функции. Аргументы внутри функции можно использовать через переменные `$1`, `$2`, и так далее.

**Возврат значений из функции:**

Функции могут возвращать статус выполнения (целое число), который можно использовать для проверки выполнения:

```bash
check_number() {
    if [ $1 -gt 10 ]; then
        return 0
    else
        return 1
    fi
}

check_number 15

if [ $? -eq 0 ]; then
    echo "Число больше 10"
else
    echo "Число меньше или равно 10"
fi
```

Здесь функция возвращает статус 0 или 1 в зависимости от условия, и результат проверяется через переменную `$?`, которая содержит код завершения последней выполненной команды.

#### 3.2 Планирование задач с `crontab`

`crontab` — это утилита для автоматического выполнения задач в заданное время. Она используется для периодического запуска скриптов и программ.

Для редактирования расписания задач используется команда:

```bash
crontab -e
```

Каждая строка в `crontab` состоит из времени запуска и команды, которую нужно выполнить. Формат записи:

```
* * * * * команда
| | | | |
| | | | ----- День недели (0 - воскресенье, 1 - понедельник и т.д.)
| | | ------- Месяц (1 - 12)
| | --------- День месяца (1 - 31)
| ----------- Часы (0 - 23)
------------- Минуты (0 - 59)
```

**Пример:**

Допустим, нужно запускать скрипт `backup.sh` каждый день в 2:30 ночи:

```bash
30 2 * * * /path/to/backup.sh
```

Для проверки расписания можно использовать команду:

```bash
crontab -l
```

Это выведет все текущие задачи, запланированные в `crontab`.

#### 3.3 Отладка и тестирование Bash-скриптов

Отладка скриптов — важная часть разработки, которая помогает находить ошибки и понимать поведение кода. В Bash есть несколько способов отладки:

- **Использование ключа `-x`**. Этот ключ выводит каждую команду перед ее выполнением, что помогает отслеживать, что происходит на каждом этапе выполнения скрипта:

```bash
bash -x script.sh
```

Пример скрипта с отладкой:

```bash
#!/bin/bash
set -x
echo "Начало скрипта"
name="Алиса"
echo "Привет, $name"
set +x
```

Ключи `set -x` и `set +x` включают и отключают вывод отладочной информации внутри скрипта.

- **Команда `echo`**. Добавляйте вывод с помощью `echo` для вывода промежуточных результатов и переменных:

```bash
echo "Значение переменной: $variable"
```

- **Проверка синтаксиса скрипта**. Используйте команду `bash -n` для проверки скрипта на синтаксические ошибки без его выполнения:

```bash
bash -n script.sh
```

#### 3.4 Обработка ошибок в скриптах

Для обработки ошибок и предотвращения неожиданных сбоев в Bash можно использовать следующие подходы:

- **`set -e`** — прекращает выполнение скрипта при любой ошибке:

```bash
#!/bin/bash
set -e

# Любая ошибка в этом скрипте приведет к его завершению
```

- **Проверка статуса выполнения команд** через `$?`:

```bash
#!/bin/bash
command1
if [ $? -ne 0 ]; then
    echo "Ошибка в выполнении command1"
    exit 1
fi
```

#### 3.5 Заключение всей лекции

В этой лекции мы прошли через основы и сложные аспекты работы с Bash. Мы начали с базовых команд, таких как `ls`, `cd` и `echo`, и изучили принципы написания скриптов, такие как использование шибанга и конвейеров команд. Мы узнали, как работать со специальными символами, перенаправлением ввода/вывода, а также рассмотрели специальные переменные и основные конструкции, такие как `if`, `case`, циклы `for` и `while`.

Во второй части лекции мы углубились в работу с переменными, аргументами командной строки и управляющими конструкциями, а также рассмотрели использование логических операторов и более сложные примеры, включая примеры из реальных конфигурационных файлов, таких как `.zshrc`.

И наконец, в третьей части лекции мы познакомились с определением функций и их использованием для структурирования кода. Мы также узнали, как планировать задачи с помощью `crontab` и отлаживать скрипты для эффективного поиска ошибок.

Bash предоставляет мощные инструменты для автоматизации задач в системах на основе Linux. Скрипты на Bash помогают не только выполнять повседневные операции, но и строить сложные сценарии для управления системными процессами, анализом данных и выполнения регулярных задач.

#### Важные выводы:
- Освоение базовых команд и понимание пайпов (конвейеров) является основой работы в Linux.
- Переменные и аргументы позволяют писать гибкие и динамичные скрипты.
- Управляющие конструкции и циклы помогают автоматизировать многократные операции и обрабатывать различные ситуации.
- Функции делают скрипты более структурированными и модульными.
- Использование `crontab` и отладка кода делают скрипты надежными и позволяют выполнять задачи в точное время.

Теперь вы обладаете знаниями, чтобы создавать сложные сценарии автоматизации, управлять задачами и эффективно взаимодействовать с системой на уровне командной строки!


продолжая натсроку ~/.zshrc

как очистить оперативу ->

как посмотреть на занятый хард -> 

ncdu 
sudo apt-get clean 
