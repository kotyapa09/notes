
https://regex101.com/

---
#### 1. Что такое regex?
Регулярные выражения (regex, от англ. *regular expressions*) — это мощный инструмент для поиска, обработки и проверки текста. Они представляют собой последовательность символов, которая задаёт шаблон для поиска или сопоставления строк. Простыми словами, regex — это как улучшенная версия функции "найти и заменить", которую вы могли видеть в текстовых редакторах, но с гораздо большими возможностями.

Примеры:
- Найти все слова, заканчивающиеся на "at".
- Проверить, соответствует ли строка формату email.
- Извлечь все телефонные номера из текста.

Основные элементы regex:
- **Символы**: Обычные буквы или цифры соответствуют самим себе (например, `a` ищет "a").
- **Метасимволы**: Специальные символы, такие как `.` (любой символ), `*` (0 или более повторений), `+` (1 или более повторений), `?` (0 или 1 повторение).
- **Классы символов**: Например, `[a-z]` — любая буква от a до z.
- **Якоря**: `^` (начало строки), `$` (конец строки).

---
#### 2. Зачем нужны регулярные выражения?
Regex нужны для автоматизации работы с текстом, когда требуется:
- **Поиск по шаблону**: Например, найти все слова длиной 4 буквы.
- **Валидация данных**: Проверить, соответствует ли введённый пользователем текст определённому формату (email, номер телефона).
- **Извлечение данных**: Выделить нужные части текста, такие как URL или даты.
- **Замена текста**: Быстро заменить все совпадения шаблона на другой текст.

Без regex пришлось бы писать сложный код для каждого случая, что отнимает время и увеличивает вероятность ошибок.

---
#### 3. Где используются регулярные выражения?
- **Программирование**: В языках вроде Python, JavaScript, Java для обработки строк (например, модуль `re` в Python).
- **Текстовые редакторы**: В Visual Studio Code, Notepad++ для поиска и замены текста.
- **Обработка данных**: В инструментах вроде Excel, SQL или при парсинге логов.
- **Командная строка**: В утилитах вроде `grep` для поиска в файлах.
- **Веб-разработка**: Проверка форм (например, валидация email на сайте).

---
#### 4. Регулярные выражения в задачах Capture The Flag (CTF)
В CTF-соревнованиях regex часто используется для поиска флагов или данных, скрытых в большом объёме текста. Флаги обычно имеют фиксированный формат, например, `FLAG{что-то}`. С помощью regex можно быстро найти такие шаблоны.

Пример:
- Дан текст: `Some text FLAG{abc123} more text FLAG{xyz789}`.
- Шаблон: `FLAG\{[a-z0-9]+\}` найдет `FLAG{abc123}` и `FLAG{xyz789}`.

Regex экономит время, позволяя избежать ручного поиска.

---
## 1. Что такое regex и зачем он нужен?
Регулярные выражения (regex) — это инструмент для работы с текстом, который позволяет находить, сопоставлять и изменять строки на основе заданных шаблонов. Они широко используются в программировании, обработке данных, валидации ввода (например, email или номера телефона) и других задачах, где нужно искать или заменять текст.

Пример: вы хотите найти все слова, начинающиеся на "c", "f" или "h" и заканчивающиеся на "at" (cat, fat, hat). Regex поможет сделать это быстро и эффективно.

---
## 2. Основные элементы regex
Чтобы составлять шаблоны, нужно знать базовые строительные блоки регулярных выражений:
### Литералы
- Это обычные символы, которые означают сами себя.
- Примеры: `a` соответствует "a", `1` соответствует "1", `cat` соответствует "cat".
### Метасимволы
- Специальные символы с особым значением:
  - `.` — любой одиночный символ (кроме перевода строки).
  - `*` — 0 или более повторений предыдущего символа.
  - `+` — 1 или более повторений предыдущего символа.
  - `?` — 0 или 1 повторение предыдущего символа.
  - `[]` — класс символов (см. ниже).
  - `^` — начало строки или отрицание внутри `[]`.
  - `$` — конец строки.
### Классы символов
- Используются внутри квадратных скобок `[]` для указания набора символов:
  - `[abc]` — соответствует одному символу: "a", "b" или "c".
  - `[a-z]` — любая строчная буква от "a" до "z".
  - `[0-9]` — любая цифра от "0" до "9".
### Отрицание в классах
- `[^abc]` — любой символ, кроме "a", "b" или "c".
- Пример: `[^0-9]` — любой символ, кроме цифры.
### Экранирование
- Если нужно использовать метасимвол как обычный символ, перед ним ставится `\`.
- Пример: `\.` соответствует точке "." вместо "любой символ".

---
## 3. Простые шаблоны
Теперь давайте научимся составлять шаблоны для разных задач.
### Сопоставление отдельных символов
- Задача: найти любой из символов "c", "o", "g".
- Шаблон: `[cog]`.
- Объяснение: `[cog]` означает "любой один символ из c, o или g".
### Сопоставление слов с общим суффиксом
- Задача: найти слова "cat", "fat", "hat".
- Шаблон: `[cfh]at`.
- Объяснение: `[cfh]` — первая буква "c", "f" или "h", затем идут литералы "a" и "t".
### Учет регистра
- Задача: найти слова "Cat", "cat", "Hat", "hat".
- Шаблон: `[CcHh]at`.
- Объяснение: `[CcHh]` — первая буква может быть "C" или "c", вторая — "H" или "h", затем "at".
### Сопоставление с цифрами
- Задача: найти "File1", "File2", "file3", ..., "File9".
- Шаблон: `[Ff]ile[1-9]`.
- Объяснение: `[Ff]` — "F" или "f", затем "ile", и `[1-9]` — любая цифра от 1 до 9.
### Исключение с использованием отрицания
- Задача: найти все имена файлов из предыдущего примера, кроме "File7".
- Шаблон: `[Ff]ile[^7]`.
- Объяснение: `[^7]` означает "любой символ, кроме 7".

---
## 4. Регистрозависимость
По умолчанию regex чувствителен к регистру: "C" и "c" — разные символы. Чтобы учесть оба регистра, нужно явно указать их в шаблоне, например, `[Cc]` для "C" или "c".

---
## 6. Распространенные ошибки
- **Забывание о регистре**: `[cat]` не найдет "Cat". Указывайте `[Cc]at`.
- **Неправильное экранирование**: если нужно найти точку, пишите `\.`, а не `.`.
- **Перепутывание `*`, `+`, `?`**: `*` — 0 или более, `+` — 1 или более, `?` — 0 или 1.

---
## 7. Советы по составлению regex
- Начинайте с простого: сначала найдите один символ, потом добавляйте детали.
- Тестируйте шаблоны на примерах, чтобы убедиться, что они работают.
- Используйте онлайн-инструменты, такие как regex101.com, для проверки.

Существуют более простые способы сопоставления больших наборов символов. Например, `\d` используется для совпадения с любой цифрой. Вот справка:

- `\d` соответствует цифре, например 9
- `\D` соответствует нецифровому символу, например A или @
- `\w` соответствует буквенно-цифровому символу, например a или 3
- `\W` соответствует небуквенно-цифровому символу, например ! или #
- `\s` соответствует пробельному символу (пробелам, табуляции и переводам строк)
- `\S` соответствует всем остальным символам (буквенно-цифровым и знакам)

Примечание: Символ подчеркивания _ включен в метасимвол `\w` и не входит в `\W`. Это означает, что `\w` будет соответствовать каждому символу в имени файла test_file.Часто нам нужен шаблон, который соответствует многократным повторениям одного типа символа подряд, и мы можем это сделать с помощью квантификаторов. Например, `{2}` используется для соответствия предшествующему символу (или метасимволу, или набору символов) ровно два раза подряд. Это означает, что `z{2}` соответствует точно двум z.

Вот справка по каждому квантификатору и количеству совпадений:

- `{12}` - ровно 12 раз
- `{1,5}` - от 1 до 5 раз
- `{2,}` - 2 или более раз
- `*` - 0 или более раз
- `+` - 1 или более раз

---
## 8. Упражнения для практики
Попробуйте сами:
1. Напишите шаблон для символов: "a", "b", "z".
2. Напишите шаблон для слов: "dog", "fog", "log".
3. Напишите шаблон для слов: "Book1", "book2", "Book3", исключая "Book2".

Ответы:
1. `[abz]`
2. `[dfl]og`
3. `[Bb]ook[^2]`

---
#### 5. Примеры в сетевых задачах
В сетевых задачах regex помогает:
- **Анализ трафика**: Извлечение IP-адресов (`\d+\.\d+\.\d+\.\d+`) из логов.
- **Парсинг HTTP-запросов**: Поиск заголовков или параметров URL.
- **Фильтрация данных**: Выборка доменных имён из списка (`\w+\.\w+`).

Пример: найти все домены вида `example.com` в тексте:
- Шаблон: `\w+\.\w+`
- Результат: `cat.xyz`, `google.com` и т.д.

---

## **I. Python (модуль `re`)**
```python
import re
```
### **1. Базовые паттерны**
- **Поиск флагов в логах** (CTF-style):
```python
re.findall(r'FLAG{[\w!@#$%^&*()_+]+}', text, re.IGNORECASE)
```
- **Валидация IPv4 с проверкой октетов**:
```python
re.search(r'^((25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)\.){3}(25[0-5]|2[0-4]\d|1\d{2})$', ip)
```
- **Извлечение Base64 строк** (с проверкой padding):
```python
re.findall(r'(?:[A-Za-z0-9+/]{4}){2,}(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?', data)
```
### **2. Продвинутые техники**
- **Positive Lookbehind для поиска паролей после ключевого слова**:
```python
re.findall(r'(?<=password:\s)[^\s]+', config_file)
```
- **Извлечение SQLi-паттернов** (например, `' OR 1=1 --`):
```python
re.search(r"'\s+OR\s+[^\s]+\s*=\s*[^\s]+\s+--", payload, re.IGNORECASE)
```
- **Поиск утечек CC-данных (Luhn-совместимые)**:
```python
re.findall(r'\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14})\b', dump)
```
### **3. Обработка сетевых данных**
- **Парсинг HTTP-заголовков из PCAP**:
```python
re.findall(r'(GET|POST|PUT|DELETE)\s+(.*?)\s+HTTP/[12]\.[01]', pcap_data)
```

- **Поиск открытых портов в nmap-скане**:
```python
re.findall(r'(\d+)/tcp\s+open\s+(\w+)', nmap_output)
```

---

## **II. Linux CLI (grep/sed/awk)**
### **1. grep (PCRE)**
- **Поиск скрытых директорий в логах Apache**:
```bash
grep -P 'GET\s+/\.(git|env|htaccess)\b' access.log
```

- **Фильтрация строк с XOR-кодированием** (CTF):
```bash
strings malware.bin | grep -E '^[A-Za-z0-9+/]+={0,2}$' | grep -v '==$'
```

- **Поиск RCE-векторов** (`;`, `&&`, `|`):
```bash
grep -P '(;\s*|\|\s*|&&\s*)(curl|wget|bash|sh)\s' logs.txt
```

### **2. sed**
- **Анонимизация IP в логах**:
```bash
sed -E 's/([0-9]{1,3}\.){3}[0-9]{1,3}/***.***.***.***/g' access.log
```

- **Подмена уязвимых версий в HTTP-ответах**:
```bash
sed -r 's/X-Powered-By: PHP\/[0-9.]+/X-Powered-By: PHP\/7.4.33/g' response.txt
```

### **3. awk**
- **Статистика атак по IP**:
```bash
awk '/Failed password/ { match($0, /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/); ip = substr($0, RSTART, RLENGTH); count[ip]++ } END { for (i in count) print i, count[i] }' auth.log
```

- **Парсинг CSV с эксплойтами** (CVE-2023-XXXXX):
```bash
awk -FPAT='("([^"]|"")*"|[^,]*),' 'NR>1 { if ($5 ~ /CVE-2023-\d{5}/) print $1,$3 }' exploits.csv
```

---

## **III. CTF & Security**
### **1. Анализ бинарников**
- **Поиск строк с шестнадцатеричными значениями**:
```bash
rabin2 -z binary | grep -E '\b([0-9a-fA-F]{2}){4,}\b'
```
- **Выявление stack canary** (0x00 + 3 random bytes + 0x00):
```bash
grep -P '\\x00[^\\x00]{3}\\x00' binary.dump
```
### **2. Web Exploitation**
- **Поиск JWT в HTTP-трафике**:
```bash
tshark -r traffic.pcap -Y 'http' -T fields -e http.cookie | grep -E 'eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+'
```
- **Обнаружение SSTI (Twig/Jinja)**:
```python
re.search(r'\{\{.*?\}\}|\{%.*?%\}', user_input)
```
### **3. Reverse Engineering**
- **Поиск AES-ключей в памяти**:
```python
re.findall(r'(?:[A-F0-9]{2}\s){16,32}', hexdump, re.IGNORECASE)
```
- **Выявление обфусцированного JS** (частичная деобфускация):
```bash
cat obfuscated.js | grep -E '\\x[0-9a-fA-F]{2}|\(function\(\)\{'
```

---
## **IV. Производительность и оптимизация**
- **Использование атомарных групп (Atomic Groups)** для предотвращения backtracking:
```python
re.compile(r'(?>(http|https))://([a-z0-9.-]+)')
```

- **Предварительная компиляция для массового сканирования**:
```python
patterns = {
    'sql_injection': re.compile(r"([';]+\s*(select|union|drop))", re.I),
    'xss': re.compile(r'<script[^>]*>|alert\(', re.I)
}
```

---
## **V. Полезные инструменты**
- **Regex debuggers**: [regex101.com](https://regex101.com/), [Debuggex](https://www.debuggex.com/)
- **Оптимизированный grep**: `ripgrep` (`rg`) с поддержока PCRE2
- **Быстрый парсинг больших логов**: `LC_ALL=C grep` (отключает Unicode для скорости)

---

**Примечания:**  
1. Для сложных задач комбинируйте regex с другими методами (например, entropy analysis для поиска ключей).  
2. Всегда экранируйте пользовательский ввод при использовании regex в веб-приложениях.  
3. В CTF часто используются нестандартные кодировки (base85, rot13+base64) — адаптируйте паттерны под конкретный кейс.












